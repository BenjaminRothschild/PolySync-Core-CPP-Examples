//PathPlanner
#include <cmath>
#include <iostream>
#include <PolySyncDataModel.hpp>

#include "SearchNode.hpp"
#include "GridMap.hpp"

using namespace cv;
using namespace std;
using namespace polysync::datamodel;

constexpr int INVALID_LOC = -1;

SearchNode::SearchNode( )
    :
    searcher( ),
    initLocation( false ),
    newLocation( false ),
    golLocX( INVALID_LOC ),
    golLocY( INVALID_LOC ),
    robLocX( INVALID_LOC ),
    robLocY( INVALID_LOC ),
    waypointCounter( 0 )
{
    setNodeName( "searchNode" );
    setNodeType( PSYNC_NODE_TYPE_SOFTWARE_ALGORITHM );

}

SearchNode::~SearchNode( ){

}

void SearchNode::initStateEvent( ) {
    registerListener( getMessageTypeByName( "ps_platform_motion_msg" ) );
}

void SearchNode::okStateEvent( ) {
    if ( golLocX == INVALID_LOC && golLocY == INVALID_LOC ) {
        searcher = std::unique_ptr<Planner>{ new Planner };
        golLocX = searcher->getGoalX( );
        golLocY = searcher->getGoalY( );

        PlatformMotionMessage msg( *this );
        msg.setHeaderTimestamp( polysync::getTimestamp() );

        // BREAKS BELOW.  setOrientation( ) and print( ) both prevent initial
        // message from sending.  Other instances of message generation work  

        //msg.setOrientation( {0.0,0.0,0.0,0.0});
        //msg.setOrientation( {double(golLocX), double(golLocY), 0, 0} );
        msg.publish( );
        //msg.print( );
        polysync::sleepMicro(1000);

        cout << "Goal Location generated by Planner Algorithm. ";
        cout << "Sending to robot." << endl << "Waiting for Robot Location.";
        cout << endl;
    } else if ( initLocation && searcher ) {
        cout << "Robot start location received by planner algorithm." << endl;
        cout << "Begin searching for optimal path from start location." << endl;
        cout << endl;
        int robIndex = searcher->world.getIndexFromState(robLocX, robLocY);
        searcher->searchAStar( robIndex );
        initLocation = false;
    }
    if ( newLocation && searcher ) {
        int robIndex = searcher->world.getIndexFromState(robLocX, robLocY);
        if ( searcher->world.checkGoal( robIndex ) ) {
            disconnectPolySync( );
            return;
        }
        int newIndex = searcher->getNextWaypoint( waypointCounter++ );
        searcher->world.getStateFromIndex( newIndex );
        robLocX = searcher->world.checkMoveIndexX;
        robLocY = searcher->world.checkMoveIndexY;

        PlatformMotionMessage msg( *this );
        msg.setHeaderTimestamp( polysync::getTimestamp() );
        msg.setOrientation( {robLocX, robLocY, 0, 0} );
        msg.publish();
        polysync::sleepMicro(1000);
        newLocation = false;
    }
}

void SearchNode::messageEvent( std::shared_ptr<polysync::Message> newMsg ) {
    if ( newMsg->getSourceGuid( ) == getGuid( ) ) {
        return;
    }
    if ( auto msg = getSubclass<PlatformMotionMessage>( newMsg ) ) {
        if ( msg->getOrientation()[0] != robLocX &&
                msg->getOrientation()[1] != robLocY ) {
            robLocX = msg->getOrientation()[0];
            robLocY = msg->getOrientation()[1];
            newLocation = true;
            if ( waypointCounter == 0 ) {
                initLocation = true;
            }
          //do stuff with PlatformMotionMessage
          //PlatformMotionMessage.print();
        }
    }
}
